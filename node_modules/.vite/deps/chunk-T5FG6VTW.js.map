{
  "version": 3,
  "sources": ["../../gsap/ScrollSmoother.js"],
  "sourcesContent": ["function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*!\n * ScrollSmoother 3.11.5\n * https://greensock.com\n *\n * @license Copyright 2008-2023, GreenSock. All rights reserved.\n * Subject to the terms at https://greensock.com/standard-license or for\n * Club GreenSock members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar gsap,\n    _coreInitted,\n    _win,\n    _doc,\n    _docEl,\n    _body,\n    _root,\n    _toArray,\n    _clamp,\n    ScrollTrigger,\n    _mainInstance,\n    _expo,\n    _getVelocityProp,\n    _inputObserver,\n    _context,\n    _onResizeDelayedCall,\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _getGSAP = function _getGSAP() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _bonusValidated = 1,\n    //<name>ScrollSmoother</name>\n_isViewport = function _isViewport(e) {\n  return !!~_root.indexOf(e);\n},\n    _getTime = Date.now,\n    _round = function _round(value) {\n  return Math.round(value * 100000) / 100000 || 0;\n},\n    _autoDistance = function _autoDistance(el, progress) {\n  // for calculating the distance (and offset) for elements with speed: \"auto\". Progress is for if it's \"above the fold\" (negative start position), so we can crop as little as possible.\n  var parent = el.parentNode || _docEl,\n      b1 = el.getBoundingClientRect(),\n      b2 = parent.getBoundingClientRect(),\n      gapTop = b2.top - b1.top,\n      gapBottom = b2.bottom - b1.bottom,\n      change = (Math.abs(gapTop) > Math.abs(gapBottom) ? gapTop : gapBottom) / (1 - progress),\n      offset = -change * progress,\n      ratio,\n      extraChange;\n\n  if (change > 0) {\n    // if the image starts at the BOTTOM of the container, adjust things so that it shows as much of the image as possible while still covering.\n    ratio = b2.height / (_win.innerHeight + b2.height);\n    extraChange = ratio === 0.5 ? b2.height * 2 : Math.min(b2.height, -change * ratio / (2 * ratio - 1)) * 2 * (progress || 1);\n    offset += progress ? -extraChange * progress : -extraChange / 2; // whatever the offset, we must double that in the opposite direction to compensate.\n\n    change += extraChange;\n  }\n\n  return {\n    change: change,\n    offset: offset\n  };\n},\n    _wrap = function _wrap(el) {\n  var wrapper = _doc.querySelector(\".ScrollSmoother-wrapper\"); // some frameworks load multiple times, so one already exists, just use that to avoid duplicates\n\n\n  if (!wrapper) {\n    wrapper = _doc.createElement(\"div\");\n    wrapper.classList.add(\"ScrollSmoother-wrapper\");\n    el.parentNode.insertBefore(wrapper, el);\n    wrapper.appendChild(el);\n  }\n\n  return wrapper;\n};\n\nexport var ScrollSmoother = /*#__PURE__*/function () {\n  function ScrollSmoother(vars) {\n    var _this = this;\n\n    _coreInitted || ScrollSmoother.register(gsap) || console.warn(\"Please gsap.registerPlugin(ScrollSmoother)\");\n    vars = this.vars = vars || {};\n    _mainInstance && _mainInstance.kill();\n    _mainInstance = this;\n\n    _context(this);\n\n    var _vars = vars,\n        smoothTouch = _vars.smoothTouch,\n        _onUpdate = _vars.onUpdate,\n        onStop = _vars.onStop,\n        smooth = _vars.smooth,\n        onFocusIn = _vars.onFocusIn,\n        normalizeScroll = _vars.normalizeScroll,\n        wholePixels = _vars.wholePixels,\n        content,\n        wrapper,\n        height,\n        mainST,\n        effects,\n        sections,\n        intervalID,\n        wrapperCSS,\n        contentCSS,\n        paused,\n        pausedNormalizer,\n        recordedRefreshScroll,\n        recordedRefreshScrub,\n        self = this,\n        effectsPrefix = vars.effectsPrefix || \"\",\n        scrollFunc = ScrollTrigger.getScrollFunc(_win),\n        smoothDuration = ScrollTrigger.isTouch === 1 ? smoothTouch === true ? 0.8 : parseFloat(smoothTouch) || 0 : smooth === 0 || smooth === false ? 0 : parseFloat(smooth) || 0.8,\n        speed = smoothDuration && +vars.speed || 1,\n        currentY = 0,\n        delta = 0,\n        startupPhase = 1,\n        tracker = _getVelocityProp(0),\n        updateVelocity = function updateVelocity() {\n      return tracker.update(-currentY);\n    },\n        scroll = {\n      y: 0\n    },\n        removeScroll = function removeScroll() {\n      return content.style.overflow = \"visible\";\n    },\n        isProxyScrolling,\n        killScrub = function killScrub(trigger) {\n      trigger.update(); // it's possible that it hasn't been synchronized with the actual scroll position yet, like if it's later in the _triggers Array. If it was already updated, it'll skip the processing anyway.\n\n      var scrub = trigger.getTween();\n\n      if (scrub) {\n        scrub.pause();\n        scrub._time = scrub._dur; // force the playhead to completion without rendering just so that when it resumes, it doesn't jump back in the .resetTo().\n\n        scrub._tTime = scrub._tDur;\n      }\n\n      isProxyScrolling = false;\n      trigger.animation.progress(trigger.progress, true);\n    },\n        render = function render(y, force) {\n      if (y !== currentY && !paused || force) {\n        wholePixels && (y = Math.round(y));\n\n        if (smoothDuration) {\n          content.style.transform = \"matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, \" + y + \", 0, 1)\"; //content.style.transform = \"translateY(\" + y + \"px)\"; // NOTE: when we used matrix3d() or set will-change: transform, it performed noticeably worse on iOS counter-intuitively!\n\n          content._gsap.y = y + \"px\";\n        }\n\n        delta = y - currentY;\n        currentY = y;\n        ScrollTrigger.isUpdating || ScrollSmoother.isRefreshing || ScrollTrigger.update(); // note: if we allowed an update() when in the middle of a refresh() it could render all the other ScrollTriggers and inside the update(), _refreshing would be true thus scrubs would jump instantly, but then on the very next update they'd continue from there. Basically this allowed update() to be called on OTHER ScrollTriggers during the refresh() of the mainST which could cause some complications. See https://greensock.com/forums/topic/35536-smoothscroller-ignoremobileresize-for-non-touch-devices\n      }\n    },\n        scrollTop = function scrollTop(value) {\n      if (arguments.length) {\n        value < 0 && (value = 0);\n        scroll.y = -value; // don't use currentY because we must accurately track the delta variable (in render() method)\n\n        isProxyScrolling = true; // otherwise, if snapping was applied (or anything that attempted to SET the scroll proxy's scroll position), we'd set the scroll here which would then (on the next tick) update the content tween/ScrollTrigger which would try to smoothly animate to that new value, thus the scrub tween would impede the progress. So we use this flag to respond accordingly in the ScrollTrigger's onUpdate and effectively force the scrub to its end immediately.\n\n        paused ? currentY = -value : render(-value);\n        ScrollTrigger.isRefreshing ? mainST.update() : scrollFunc(value / speed); // during a refresh, we revert all scrollers to 0 and then put them back. We shouldn't force the window to that value too during the refresh.\n\n        return this;\n      }\n\n      return -currentY;\n    },\n        resizeObserver = typeof ResizeObserver !== \"undefined\" && vars.autoResize !== false && new ResizeObserver(function () {\n      if (!ScrollTrigger.isRefreshing) {\n        var max = ScrollTrigger.maxScroll(wrapper);\n        max < -currentY && scrollTop(max); // if the user scrolled down to the bottom, for example, and then the page resizes smaller, we should adjust things accordingly right away so that the scroll position isn't past the very end.\n\n        _onResizeDelayedCall.restart(true);\n      }\n    }),\n        lastFocusElement,\n        _onFocusIn = function _onFocusIn(e) {\n      // when the focus changes, make sure that element is on-screen\n      wrapper.scrollTop = 0;\n\n      if (e.target.contains && e.target.contains(wrapper) || onFocusIn && onFocusIn(_this, e) === false) {\n        return;\n      }\n\n      ScrollTrigger.isInViewport(e.target) || e.target === lastFocusElement || _this.scrollTo(e.target, false, \"center center\");\n      lastFocusElement = e.target;\n    },\n        adjustParallaxPosition = function adjustParallaxPosition(triggers, createdAfterEffectWasApplied) {\n      var pins, start, dif, markers;\n      effects.forEach(function (st) {\n        pins = st.pins;\n        markers = st.markers;\n        triggers.forEach(function (trig) {\n          if (st.trigger && trig.trigger && st !== trig && (trig.trigger === st.trigger || trig.pinnedContainer === st.trigger || st.trigger.contains(trig.trigger))) {\n            start = trig.start;\n            dif = (start - st.start - st.offset) / st.ratio - (start - st.start); // createdAfterEffectWasApplied && (dif -= (gsap.getProperty(st.trigger, \"y\") - st.startY) / st.ratio); // the effect applied a y offset, so if the ScrollTrigger was created after that, it'll be based on that position so we must compensate. Later we added code to ScrollTrigger to roll back in this situation anyway, so this isn't necessary. Saving it in case a situation arises where it comes in handy.\n\n            pins.forEach(function (p) {\n              return dif -= p.distance / st.ratio - p.distance;\n            });\n            trig.setPositions(start + dif, trig.end + dif);\n            trig.markerStart && markers.push(gsap.quickSetter([trig.markerStart, trig.markerEnd], \"y\", \"px\"));\n\n            if (trig.pin && trig.end > 0) {\n              dif = trig.end - trig.start;\n              pins.push({\n                start: trig.start,\n                end: trig.end,\n                distance: dif,\n                trig: trig\n              });\n              st.setPositions(st.start, st.end + dif);\n              st.vars.onRefresh(st);\n            }\n          }\n        });\n      });\n    },\n        onRefresh = function onRefresh() {\n      removeScroll();\n      requestAnimationFrame(removeScroll);\n\n      if (effects) {\n        // adjust all the effect start/end positions including any pins!\n        effects.forEach(function (st) {\n          var start = st.start,\n              end = st.auto ? Math.min(ScrollTrigger.maxScroll(st.scroller), st.end) : start + (st.end - start) / st.ratio,\n              offset = (end - st.end) / 2; // we split the difference so that it reaches its natural position in the MIDDLE of the viewport\n\n          start -= offset;\n          end -= offset;\n          st.offset = offset || 0.0001; // we assign at least a tiny value because we check in the onUpdate for .offset being set in order to apply values.\n\n          st.pins.length = 0;\n          st.setPositions(Math.min(start, end), Math.max(start, end));\n          st.vars.onRefresh(st);\n        });\n        adjustParallaxPosition(ScrollTrigger.sort());\n      }\n\n      tracker.reset();\n    },\n        addOnRefresh = function addOnRefresh() {\n      return ScrollTrigger.addEventListener(\"refresh\", onRefresh);\n    },\n        restoreEffects = function restoreEffects() {\n      return effects && effects.forEach(function (st) {\n        return st.vars.onRefresh(st);\n      });\n    },\n        revertEffects = function revertEffects() {\n      effects && effects.forEach(function (st) {\n        return st.vars.onRefreshInit(st);\n      });\n      return restoreEffects;\n    },\n        effectValueGetter = function effectValueGetter(name, value, index, el) {\n      return function () {\n        var v = typeof value === \"function\" ? value(index, el) : value;\n        v || v === 0 || (v = el.getAttribute(\"data-\" + effectsPrefix + name) || (name === \"speed\" ? 1 : 0));\n        el.setAttribute(\"data-\" + effectsPrefix + name, v);\n        return v === \"auto\" ? v : parseFloat(v);\n      };\n    },\n        createEffect = function createEffect(el, speed, lag, index, effectsPadding) {\n      effectsPadding = (typeof effectsPadding === \"function\" ? effectsPadding(index, el) : effectsPadding) || 0;\n\n      var getSpeed = effectValueGetter(\"speed\", speed, index, el),\n          getLag = effectValueGetter(\"lag\", lag, index, el),\n          startY = gsap.getProperty(el, \"y\"),\n          cache = el._gsap,\n          ratio,\n          st,\n          autoSpeed,\n          scrub,\n          progressOffset,\n          yOffset,\n          initDynamicValues = function initDynamicValues() {\n        speed = getSpeed();\n        lag = getLag();\n        ratio = parseFloat(speed) || 1;\n        autoSpeed = speed === \"auto\";\n        progressOffset = autoSpeed ? 0 : 0.5;\n        scrub && scrub.kill();\n        scrub = lag && gsap.to(el, {\n          ease: _expo,\n          overwrite: false,\n          y: \"+=0\",\n          duration: lag\n        });\n\n        if (st) {\n          st.ratio = ratio;\n          st.autoSpeed = autoSpeed;\n        }\n      },\n          revert = function revert() {\n        cache.y = startY + \"px\";\n        cache.renderTransform(1);\n        initDynamicValues();\n      },\n          pins = [],\n          markers = [],\n          change = 0,\n          updateChange = function updateChange(self) {\n        if (autoSpeed) {\n          revert();\n\n          var auto = _autoDistance(el, _clamp(0, 1, -self.start / (self.end - self.start)));\n\n          change = auto.change;\n          yOffset = auto.offset;\n        } else {\n          change = (self.end - self.start) * (1 - ratio);\n          yOffset = 0;\n        }\n\n        pins.forEach(function (p) {\n          return change -= p.distance * (1 - ratio);\n        });\n        self.vars.onUpdate(self);\n        scrub && scrub.progress(1);\n      };\n\n      initDynamicValues();\n\n      if (ratio !== 1 || autoSpeed || scrub) {\n        st = ScrollTrigger.create({\n          trigger: autoSpeed ? el.parentNode : el,\n          start: \"top bottom+=\" + effectsPadding,\n          end: \"bottom top-=\" + effectsPadding,\n          scroller: wrapper,\n          scrub: true,\n          refreshPriority: -999,\n          // must update AFTER any other ScrollTrigger pins\n          onRefreshInit: revert,\n          onRefresh: updateChange,\n          onKill: function onKill(self) {\n            var i = effects.indexOf(self);\n            i >= 0 && effects.splice(i, 1);\n            revert();\n          },\n          onUpdate: function onUpdate(self) {\n            var y = startY + change * (self.progress - progressOffset),\n                i = pins.length,\n                extraY = 0,\n                pin,\n                scrollY,\n                end;\n\n            if (self.offset) {\n              // wait until the effects are adjusted.\n              if (i) {\n                // pinning must be handled in a special way because when pinned, slope changes to 1.\n                scrollY = -currentY; // -scroll.y;\n\n                end = self.end;\n\n                while (i--) {\n                  pin = pins[i];\n\n                  if (pin.trig.isActive || scrollY >= pin.start && scrollY <= pin.end) {\n                    // currently pinned so no need to set anything\n                    if (scrub) {\n                      pin.trig.progress += pin.trig.direction < 0 ? 0.001 : -0.001; // just to make absolutely sure that it renders (if the progress didn't change, it'll skip)\n\n                      pin.trig.update(0, 0, 1);\n                      scrub.resetTo(\"y\", parseFloat(cache.y), -delta, true);\n                      startupPhase && scrub.progress(1);\n                    }\n\n                    return;\n                  }\n\n                  scrollY > pin.end && (extraY += pin.distance);\n                  end -= pin.distance;\n                }\n\n                y = startY + extraY + change * ((gsap.utils.clamp(self.start, self.end, scrollY) - self.start - extraY) / (end - self.start) - progressOffset);\n              }\n\n              y = _round(y + yOffset);\n              markers.length && !autoSpeed && markers.forEach(function (setter) {\n                return setter(y - extraY);\n              });\n\n              if (scrub) {\n                scrub.resetTo(\"y\", y, -delta, true);\n                startupPhase && scrub.progress(1);\n              } else {\n                cache.y = y + \"px\";\n                cache.renderTransform(1);\n              }\n            }\n          }\n        });\n        updateChange(st);\n        gsap.core.getCache(st.trigger).stRevert = revertEffects; // if user calls ScrollSmoother.create() with effects and THEN creates a ScrollTrigger on the same trigger element, the effect would throw off the start/end positions thus we needed a way to revert things when creating a new ScrollTrigger in that scenario, so we use this stRevert property of the GSCache inside ScrollTrigger.\n\n        st.startY = startY;\n        st.pins = pins;\n        st.markers = markers;\n        st.ratio = ratio;\n        st.autoSpeed = autoSpeed;\n        el.style.willChange = \"transform\";\n      }\n\n      return st;\n    };\n\n    addOnRefresh();\n    ScrollTrigger.addEventListener(\"killAll\", addOnRefresh);\n    gsap.delayedCall(0.5, function () {\n      return startupPhase = 0;\n    });\n    this.scrollTop = scrollTop;\n\n    this.scrollTo = function (target, smooth, position) {\n      var p = gsap.utils.clamp(0, ScrollTrigger.maxScroll(_win), isNaN(target) ? _this.offset(target, position) : +target);\n      !smooth ? scrollTop(p) : paused ? gsap.to(_this, {\n        duration: smoothDuration,\n        scrollTop: p,\n        overwrite: \"auto\",\n        ease: _expo\n      }) : scrollFunc(p);\n    };\n\n    this.offset = function (target, position) {\n      target = _toArray(target)[0];\n      var cssText = target.style.cssText,\n          // because if there's an effect applied, we revert(). We need to restore.\n      st = ScrollTrigger.create({\n        trigger: target,\n        start: position || \"top top\"\n      }),\n          y;\n      effects && adjustParallaxPosition([st], true);\n      y = st.start / speed;\n      st.kill(false);\n      target.style.cssText = cssText;\n      gsap.core.getCache(target).uncache = 1;\n      return y;\n    };\n\n    function refreshHeight() {\n      height = content.clientHeight;\n      content.style.overflow = \"visible\";\n      _body.style.height = _win.innerHeight + (height - _win.innerHeight) / speed + \"px\";\n      return height - _win.innerHeight;\n    }\n\n    this.content = function (element) {\n      if (arguments.length) {\n        var newContent = _toArray(element || \"#smooth-content\")[0] || console.warn(\"ScrollSmoother needs a valid content element.\") || _body.children[0];\n\n        if (newContent !== content) {\n          content = newContent;\n          contentCSS = content.getAttribute(\"style\") || \"\";\n          resizeObserver && resizeObserver.observe(content);\n          gsap.set(content, {\n            overflow: \"visible\",\n            width: \"100%\",\n            boxSizing: \"border-box\",\n            y: \"+=0\"\n          });\n          smoothDuration || gsap.set(content, {\n            clearProps: \"transform\"\n          });\n        }\n\n        return this;\n      }\n\n      return content;\n    };\n\n    this.wrapper = function (element) {\n      if (arguments.length) {\n        wrapper = _toArray(element || \"#smooth-wrapper\")[0] || _wrap(content);\n        wrapperCSS = wrapper.getAttribute(\"style\") || \"\";\n        refreshHeight();\n        gsap.set(wrapper, smoothDuration ? {\n          overflow: \"hidden\",\n          position: \"fixed\",\n          height: \"100%\",\n          width: \"100%\",\n          top: 0,\n          left: 0,\n          right: 0,\n          bottom: 0\n        } : {\n          overflow: \"visible\",\n          position: \"relative\",\n          width: \"100%\",\n          height: \"auto\",\n          top: \"auto\",\n          bottom: \"auto\",\n          left: \"auto\",\n          right: \"auto\"\n        });\n        return this;\n      }\n\n      return wrapper;\n    };\n\n    this.effects = function (targets, config) {\n      var _effects;\n\n      effects || (effects = []);\n\n      if (!targets) {\n        return effects.slice(0);\n      }\n\n      targets = _toArray(targets);\n      targets.forEach(function (target) {\n        var i = effects.length;\n\n        while (i--) {\n          effects[i].trigger === target && effects[i].kill(); // will automatically splice() it from the effects Array in the onKill\n        }\n      });\n      config = config || {};\n      var _config = config,\n          speed = _config.speed,\n          lag = _config.lag,\n          effectsPadding = _config.effectsPadding,\n          effectsToAdd = [],\n          i,\n          st;\n\n      for (i = 0; i < targets.length; i++) {\n        st = createEffect(targets[i], speed, lag, i, effectsPadding);\n        st && effectsToAdd.push(st);\n      }\n\n      (_effects = effects).push.apply(_effects, effectsToAdd);\n\n      return effectsToAdd;\n    };\n\n    this.sections = function (targets, config) {\n      var _sections;\n\n      sections || (sections = []);\n\n      if (!targets) {\n        return sections.slice(0);\n      }\n\n      var newSections = _toArray(targets).map(function (el) {\n        return ScrollTrigger.create({\n          trigger: el,\n          start: \"top 120%\",\n          end: \"bottom -20%\",\n          onToggle: function onToggle(self) {\n            el.style.opacity = self.isActive ? \"1\" : \"0\";\n            el.style.pointerEvents = self.isActive ? \"all\" : \"none\";\n          }\n        });\n      });\n\n      config && config.add ? (_sections = sections).push.apply(_sections, newSections) : sections = newSections.slice(0);\n      return newSections;\n    };\n\n    this.content(vars.content);\n    this.wrapper(vars.wrapper);\n\n    this.render = function (y) {\n      return render(y || y === 0 ? y : currentY);\n    };\n\n    this.getVelocity = function () {\n      return tracker.getVelocity(-currentY);\n    };\n\n    ScrollTrigger.scrollerProxy(wrapper, {\n      scrollTop: scrollTop,\n      scrollHeight: function scrollHeight() {\n        return refreshHeight() && _body.scrollHeight;\n      },\n      fixedMarkers: vars.fixedMarkers !== false && !!smoothDuration,\n      content: content,\n      getBoundingClientRect: function getBoundingClientRect() {\n        return {\n          top: 0,\n          left: 0,\n          width: _win.innerWidth,\n          height: _win.innerHeight\n        };\n      }\n    });\n    ScrollTrigger.defaults({\n      scroller: wrapper\n    });\n    var existingScrollTriggers = ScrollTrigger.getAll().filter(function (st) {\n      return st.scroller === _win || st.scroller === wrapper;\n    });\n    existingScrollTriggers.forEach(function (st) {\n      return st.revert(true, true);\n    }); // in case it's in an environment like React where child components that have ScrollTriggers instantiate BEFORE the parent that does ScrollSmoother.create(...);\n\n    mainST = ScrollTrigger.create({\n      animation: gsap.fromTo(scroll, {\n        y: 0\n      }, {\n        y: function y() {\n          return -refreshHeight();\n        },\n        immediateRender: false,\n        ease: \"none\",\n        data: \"ScrollSmoother\",\n        duration: 100,\n        // for added precision\n        onUpdate: function onUpdate() {\n          if (this._dur) {\n            // skip when it's the \"from\" part of the tween (setting the startAt)\n            var force = isProxyScrolling;\n\n            if (force) {\n              killScrub(mainST);\n              scroll.y = currentY;\n            }\n\n            render(scroll.y, force);\n            updateVelocity();\n            _onUpdate && !paused && _onUpdate(self);\n          }\n        }\n      }),\n      onRefreshInit: function onRefreshInit(self) {\n        ScrollSmoother.isRefreshing = true;\n\n        if (effects) {\n          var pins = ScrollTrigger.getAll().filter(function (st) {\n            return !!st.pin;\n          });\n          effects.forEach(function (st) {\n            if (!st.vars.pinnedContainer) {\n              pins.forEach(function (pinST) {\n                if (pinST.pin.contains(st.trigger)) {\n                  var v = st.vars;\n                  v.pinnedContainer = pinST.pin;\n                  st.vars = null; // otherwise, it'll self.kill(), triggering the onKill()\n\n                  st.init(v, st.animation);\n                }\n              });\n            }\n          });\n        }\n\n        var scrub = self.getTween();\n        recordedRefreshScrub = scrub && scrub._end > scrub._dp._time; // don't use scrub.progress() < 1 because we may have called killScrub() recently in which case it'll report progress() as 1 when we were actually in the middle of a scrub. That's why we tap into the _end instead.\n\n        recordedRefreshScroll = currentY;\n        scroll.y = 0;\n\n        if (smoothDuration) {\n          ScrollTrigger.isTouch === 1 && (wrapper.style.position = \"absolute\"); // Safari 16 has a major bug - if you set wrapper.scrollTop to 0 (even if it's already 0), it blocks the whole page from scrolling page non-scrollable! See https://bugs.webkit.org/show_bug.cgi?id=245300 and https://codepen.io/GreenSock/pen/YzLZVOz. Originally we set pointer-events: none on the wrapper temporarily, and set it back to all after setting scrollTop to 0, but that could cause mouseenter/mouseleave/etc. events to fire too, so we opted to set the position to absolute and then back to fixed after setting scrollTop.\n\n          wrapper.scrollTop = 0; // set wrapper.scrollTop to 0 because in some very rare situations, the browser will auto-set that, like if there's a hash in the link or changing focus to an off-screen input\n\n          ScrollTrigger.isTouch === 1 && (wrapper.style.position = \"fixed\");\n        }\n      },\n      onRefresh: function onRefresh(self) {\n        self.animation.invalidate(); // because pinnedContainers may have been found in ScrollTrigger's _refreshAll() that extend the height. Without this, it may prevent the user from being able to scroll all the way down.\n\n        self.setPositions(self.start, refreshHeight() / speed);\n        recordedRefreshScrub || killScrub(self);\n        scroll.y = -scrollFunc() * speed; // in 3.11.1, we shifted to forcing the scroll position to 0 during the entire refreshAll() in ScrollTrigger and then restored the scroll position AFTER everything had been updated, thus we should always make these adjustments AFTER a full refresh rather than putting it in the onRefresh() of the individual mainST ScrollTrigger which would fire before the scroll position was restored.\n\n        render(scroll.y);\n        startupPhase || self.animation.progress(gsap.utils.clamp(0, 1, recordedRefreshScroll / speed / -self.end));\n\n        if (recordedRefreshScrub) {\n          // we need to trigger the scrub to happen again\n          self.progress -= 0.001;\n          self.update();\n        }\n\n        ScrollSmoother.isRefreshing = false;\n      },\n      id: \"ScrollSmoother\",\n      scroller: _win,\n      invalidateOnRefresh: true,\n      start: 0,\n      refreshPriority: -9999,\n      // because all other pins, etc. should be calculated first before this figures out the height of the body. BUT this should also update FIRST so that the scroll position on the proxy is up-to-date when all the ScrollTriggers calculate their progress! -9999 is a special number that ScrollTrigger looks for to handle in this way.\n      end: function end() {\n        return refreshHeight() / speed;\n      },\n      onScrubComplete: function onScrubComplete() {\n        tracker.reset();\n        onStop && onStop(_this);\n      },\n      scrub: smoothDuration || true\n    });\n\n    this.smooth = function (value) {\n      if (arguments.length) {\n        smoothDuration = value || 0;\n        speed = smoothDuration && +vars.speed || 1;\n        mainST.scrubDuration(value);\n      }\n\n      return mainST.getTween() ? mainST.getTween().duration() : 0;\n    };\n\n    mainST.getTween() && (mainST.getTween().vars.ease = vars.ease || _expo);\n    this.scrollTrigger = mainST;\n    vars.effects && this.effects(vars.effects === true ? \"[data-\" + effectsPrefix + \"speed], [data-\" + effectsPrefix + \"lag]\" : vars.effects, {\n      effectsPadding: vars.effectsPadding\n    });\n    vars.sections && this.sections(vars.sections === true ? \"[data-section]\" : vars.sections);\n    existingScrollTriggers.forEach(function (st) {\n      st.vars.scroller = wrapper;\n      st.revert(false, true);\n      st.init(st.vars, st.animation);\n    });\n\n    this.paused = function (value, allowNestedScroll) {\n      if (arguments.length) {\n        if (!!paused !== value) {\n          if (value) {\n            // pause\n            mainST.getTween() && mainST.getTween().pause();\n            scrollFunc(-currentY / speed);\n            tracker.reset();\n            pausedNormalizer = ScrollTrigger.normalizeScroll();\n            pausedNormalizer && pausedNormalizer.disable(); // otherwise the normalizer would try to scroll the page on things like wheel events.\n\n            paused = ScrollTrigger.observe({\n              preventDefault: true,\n              type: \"wheel,touch,scroll\",\n              debounce: false,\n              allowClicks: true,\n              onChangeY: function onChangeY() {\n                return scrollTop(-currentY);\n              } // refuse to scroll\n\n            });\n            paused.nested = _inputObserver(_docEl, \"wheel,touch,scroll\", true, allowNestedScroll !== false); // allow nested scrolling, like modals\n          } else {\n            // resume\n            paused.nested.kill();\n            paused.kill();\n            paused = 0;\n            pausedNormalizer && pausedNormalizer.enable();\n            mainST.progress = (-currentY / speed - mainST.start) / (mainST.end - mainST.start);\n            killScrub(mainST);\n          }\n        }\n\n        return this;\n      }\n\n      return !!paused;\n    };\n\n    this.kill = this.revert = function () {\n      _this.paused(false);\n\n      killScrub(mainST);\n      mainST.kill();\n      var triggers = (effects || []).concat(sections || []),\n          i = triggers.length;\n\n      while (i--) {\n        // make sure we go backwards because the onKill() will effects.splice(index, 1) and we don't want to skip\n        triggers[i].kill();\n      }\n\n      ScrollTrigger.scrollerProxy(wrapper);\n      ScrollTrigger.removeEventListener(\"killAll\", addOnRefresh);\n      ScrollTrigger.removeEventListener(\"refresh\", onRefresh);\n      wrapper.style.cssText = wrapperCSS;\n      content.style.cssText = contentCSS;\n      var defaults = ScrollTrigger.defaults({});\n      defaults && defaults.scroller === wrapper && ScrollTrigger.defaults({\n        scroller: _win\n      });\n      _this.normalizer && ScrollTrigger.normalizeScroll(false);\n      clearInterval(intervalID);\n      _mainInstance = null;\n      resizeObserver && resizeObserver.disconnect();\n\n      _body.style.removeProperty(\"height\");\n\n      _win.removeEventListener(\"focusin\", _onFocusIn);\n    };\n\n    this.refresh = function (soft, force) {\n      return mainST.refresh(soft, force);\n    };\n\n    if (normalizeScroll) {\n      this.normalizer = ScrollTrigger.normalizeScroll(normalizeScroll === true ? {\n        debounce: true,\n        content: !smoothDuration && content\n      } : normalizeScroll);\n    }\n\n    ScrollTrigger.config(vars); // in case user passes in ignoreMobileResize for example\n\n    \"overscrollBehavior\" in _win.getComputedStyle(_body) && gsap.set([_body, _docEl], {\n      overscrollBehavior: \"none\"\n    });\n    \"scrollBehavior\" in _win.getComputedStyle(_body) && gsap.set([_body, _docEl], {\n      scrollBehavior: \"auto\"\n    }); // if the user hits the tab key (or whatever) to shift focus to an element that's off-screen, center that element.\n\n    _win.addEventListener(\"focusin\", _onFocusIn);\n\n    intervalID = setInterval(updateVelocity, 250);\n    _doc.readyState === \"loading\" || requestAnimationFrame(function () {\n      return ScrollTrigger.refresh();\n    });\n  }\n\n  ScrollSmoother.register = function register(core) {\n    if (!_coreInitted) {\n      gsap = core || _getGSAP();\n\n      if (_windowExists() && window.document) {\n        _win = window;\n        _doc = document;\n        _docEl = _doc.documentElement;\n        _body = _doc.body;\n      }\n\n      if (gsap) {\n        _toArray = gsap.utils.toArray;\n        _clamp = gsap.utils.clamp;\n        _expo = gsap.parseEase(\"expo\");\n\n        _context = gsap.core.context || function () {};\n\n        _onResizeDelayedCall = gsap.delayedCall(0.2, function () {\n          return ScrollTrigger.isRefreshing || _mainInstance && _mainInstance.refresh();\n        }).pause();\n        ScrollTrigger = gsap.core.globals().ScrollTrigger;\n        gsap.core.globals(\"ScrollSmoother\", ScrollSmoother); // must register the global manually because in Internet Explorer, functions (classes) don't have a \"name\" property.\n        //\tgsap.ticker.lagSmoothing(50, 100); // generally people don't want things to jump (honoring smoothness over time is better with smooth scrolling)\n\n        if (_body && ScrollTrigger) {\n          _root = [_win, _doc, _docEl, _body];\n          _getVelocityProp = ScrollTrigger.core._getVelocityProp;\n          _inputObserver = ScrollTrigger.core._inputObserver;\n          ScrollSmoother.refresh = ScrollTrigger.refresh;\n          _coreInitted = 1;\n        }\n      }\n    }\n\n    return _coreInitted;\n  };\n\n  _createClass(ScrollSmoother, [{\n    key: \"progress\",\n    get: function get() {\n      return this.scrollTrigger ? this.scrollTrigger.animation._time / 100 : 0;\n    }\n  }]);\n\n  return ScrollSmoother;\n}();\nScrollSmoother.version = \"3.11.5\";\n\nScrollSmoother.create = function (vars) {\n  return _mainInstance && vars && _mainInstance.content() === _toArray(vars.content)[0] ? _mainInstance : new ScrollSmoother(vars);\n};\n\nScrollSmoother.get = function () {\n  return _mainInstance;\n};\n\n_getGSAP() && gsap.registerPlugin(ScrollSmoother);\nexport { ScrollSmoother as default };"],
  "mappings": "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",
  "names": ["_windowExists", "_getGSAP", "_round", "_autoDistance", "_wrap", "ScrollSmoother", "updateVelocity", "removeScroll", "killScrub", "render", "scrollTop", "_onFocusIn", "adjustParallaxPosition", "onRefresh", "addOnRefresh", "restoreEffects", "revertEffects", "effectValueGetter", "createEffect", "speed", "initDynamicValues", "revert", "updateChange", "self", "smooth", "i"]
}
